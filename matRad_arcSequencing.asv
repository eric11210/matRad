function beam = matRad_arcSequencing(beam,stf)
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% The sequencing algorithm generates an a priori unkown number of aperture.
% We only want to keep a certain number of them (numToKeep).  These will be
% the ones with the highest intensity-area product.
%
%
% call
%   beam =
%   matRad_arcSequencing(beam)
%
% input
%   beam:               beam struct with shapes and weights only at the
%                       initGantyAngles
%
%
% output
%   beam:               beam struct with shapes and weights distributed to
%                       the correct optGantryAngles
%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Copyright 2015 the matRad development team.
%
% This file is part of the matRad project. It is subject to the license
% terms in the LICENSE file found in the top-level directory of this
% distribution and at https://github.com/e0404/matRad/LICENSES.txt. No part
% of the matRad project, including this file, may be copied, modified,
% propagated, or distributed except according to the terms contained in the
% LICENSE file.
%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


numOfBeams = numel(stf);

leafDir = 1;

for i = 1:numOfBeams
    
    if stf(i).initializeBeam
        
        %Spread apertures to each child angle
        %according to the trajectory (mean leaf position). Assume that
        %shapes are already order in increased (left to right) position
        leafDir = -1*leafDir;
        
        childrenIndex = stf(i).beamChildrenIndex;
        if leafDir == -1
            % reverse order of shapes
            childrenIndex = flipud(childrenIndex);
        end
        
        count = 1;
        numOfShapes = beam(i).numOfShapes;
        
        for shape = 1:numOfShapes
            childIndex = childrenIndex(count);
            
            if childIndex == i
                % do not overwrite information, since we will need it for
                % the remaining beams (DAO, not init)
                beam(childIndex).tempNumOfShapes = 1;
                beam(childIndex).tempShapes = beam(childIndex).shapes(:,:,shape); %store segment temporarily, don't erase segments for initialized beams
                beam(childIndex).tempShapesWeight = beam(childIndex).shapesWeight(shape); %sequencing.beam(i).shapesWeight(sequencing.beam(childIndex).maxDAPSeg)
                beam(childIndex).fluence = beam(childIndex).tempShapes;
                beam(childIndex).sum = beam(childIndex).tempShapesWeight*beam(childIndex).tempShapes;
            else
                % don't worry about overwriting
                sequencing.beam(childIndex).numOfShapes = 1;
                beam(childIndex).shapes = beam(childIndex).shapes(:,:,shape); %store segment temporarily, don't erase segments for initialized beams
                beam(childIndex).shapesWeight = beam(childIndex).shapesWeight(shape); %sequencing.beam(i).shapesWeight(sequencing.beam(childIndex).maxDAPSeg)
                beam(childIndex).fluence = beam(childIndex).tempShapes;
                beam(childIndex).sum = beam(childIndex).tempShapesWeight*beam(childIndex).tempShapes;
            end
            
            count = count+1;
        end
    else
        % if beam isn't an FMO beam, then there is no info in the beam
        % struct
        continue
    end
end

1;




